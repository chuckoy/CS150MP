class recursive_descent:
	"""
		:param inFileName:  name of input file
		:param resWords: reservedWords class instance
	""" 
	def __init__( self, inFileName, dicts ):
		# open file and store pointer to in_fp
		in_fp = open( inFileName, 'r' )
		self.token = 0
		self.noParen = 0

		lexeme = []
		charClass = 0
		nextChar = ""
		nextToken = 0

		TOKEN = dicts.getTokenDict()
		RESERVED_WORDS = dicts.getReservedWordsDict()
		"""
			ERROR CODES:
			100	:	Reserved word conflict
		"""

	# this method is called when we want to start lexing and parsing
	def run( self ):
		self.lex()
		self.start()

	def start( self ):
		print "Enter start()"
		self.declaration()
		print "Exit start()"

	def declaration( self ):
		print "Enter declaration()"
		if nextToken == TOKEN[ IDENT ]:
			self.type()
			self.var()
			if nextToken == TOKEN[ ASSIGN_OP ]:
				self.lex()
				self.expr()
			else:
				self.error()
		print "Exit declaration()"

	def expr( self ):#E->TE'
		print "Enter expr()"
		self.term()#parse the first term
		self.exprP()
		print "Exit expr()"
	def exprP( self ):# E'->{(+|-)TE'}
		print "Enter exprP()"
		if nextToken != CHAR_CLASSES[ EOF ]:
			if nextToken == TOKEN[ ADD_OP ] or nextToken == TOKEN[ SUB_OP ]:
				self.lex()
				self.term()
				self.exprP()
		print "Exit exprP()"
	def term( self ):# T->FT'
		print "Enter term()"
		self.factor()#parse the first factor
		self.termP()
		print "Exit term()"
	def termP( self ):# T'->{(*|\)FT'}
		print "Enter termP()"
		while self.nextToken==self.MULT_OP or self.nextToken==self.DIV_OP:#as long as * or / comes next
			self.lex()
			self.factor()
		print "Exit termP()"
	def factor( self ):# F->(E)|id
		print "Enter factor()"
		#self.lex()
		if self.nextToken==self.IDENT or self.nextToken==self.INT_LIT:
			#self.lex()#get token 
			self.id()

		else: #(<expr>)
			if self.nextToken==self.LEFT_PAREN:
				self.lex()
				self.expr()
				if self.nextToken==self.RIGHT_PAREN:
					self.lex()
				else:
					self.error()
			else: #It was not an id, an integer literal, or a left parenthesis
				self.error()
		print "Exit factor()"

	def id( self ):# id->(a|b|c)
		print "Enter <id>"
		self.lex()
		if lexeme in RESERVED_WORDS:
			self.error( 100 )
		print "Exit <id>"

	def error( self, errorCode = 0 ):
		if errorCode == 0:
			tokens=['+','-','/','*','a','b','c','(',')','=']
			if tokens.count("".join(self.lexeme))>0:#error caused by lexeme read at a rule
				print "Syntax Error"
			else:
				print "Lexical Error in input. Lexeme","".join(self.lexeme),"is not in the grammar. Input is not generated by the grammar."
		elif errorCode == 100:
			print "Identifier expected. Reserved word gotten."
