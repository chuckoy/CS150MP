#Romero, Klarizze
#ME1 - Recursive Descent Parsing 
class lexicalAnalyzer:
	def __init__(self):
		self.in_fp=[]
		self.i=0
		self.lexeme=[]
		self.charClass=0
		self.lexLen=0
		self.token=0
		self.nextToken=0
		self.noParen=0
		# /* Character classes */
		self.LETTER=0
		self.DIGIT=1
		self.UNKNOWN=99
		# /* Token codes */
		self.INT_LIT=10
		self.IDENT=11
		self.ASSIGN_OP=20
		self.ADD_OP=21
		self.SUB_OP=22
		self.MULT_OP=23
		self.DIV_OP=24
		self.LEFT_PAREN=25
		self.RIGHT_PAREN=26
	
	def getChar(self):	
		if self.i<len(self.in_fp): 
			self.nextChar = self.in_fp[self.i]
			self.i=self.i+1
			if (self.nextChar.isalpha()) and (self.nextChar=='a' or self.nextChar=='b' or self.nextChar=='c'):
				self.charClass = self.LETTER 
			elif (self.nextChar.isdigit()):
				self.charClass = self.DIGIT 
			else: 
				self.charClass = self.UNKNOWN 
		else:
			self.charClass =  -1 
	# /* addChar - a function to add nextChar to lexeme */
	def addChar(self):
		if len(self.lexeme) <= 98:
			self.lexeme.append(self.nextChar)
			self.lexlen=self.lexLen+1
		else:
			print "Error - lexeme is too long \n"
	# /* lookup - a function to lookup operators and parentheses
	# and return the token */
	def lookup(self,ch):
		if ch=='(':
			self.addChar() 
			self.nextToken = self.LEFT_PAREN 
			self.noParen=self.noParen+1#counts no. of left paren
		elif ch==')':
			self.addChar() 
			self.nextToken = self.RIGHT_PAREN 
			self.noParen=self.noParen-1#if there's a matching right paren, decrement
		elif ch=='+':
			self.addChar() 
			self.nextToken = self.ADD_OP 
		elif ch=='-':
			self.addChar() 
			self.nextToken = self.SUB_OP 
		elif ch=='*':
			self.addChar() 
			self.nextToken = self.MULT_OP 
		elif ch=='/':
			self.addChar() 
			self.nextToken = self.DIV_OP 
		elif ch=='=':
			self.addChar() 
			self.nextToken = self.ASSIGN_OP 
		else:
			self.addChar() 
			self.nextToken =  -1 
		
		return self.nextToken 
	# /* getNonBlank - a function to call getChar until it
	# returns a non-whitespace character */

	def getNonBlank(self):
		while self.nextChar.isspace():
			self.getChar() 
	# /* lex - a simple lexical analyzer for arithmetic
	# expressions */
	def lex(self):
		self.lexLen = 0 
		self.lexeme=[]
		self.getNonBlank() 
		#/* Parse letter literals */
		if self.charClass==self.LETTER:
			self.addChar() 
			self.getChar() 
			while self.charClass == self.LETTER or self.charClass == self.DIGIT:
				self.addChar() 
				self.getChar() 
			
			self.nextToken = self.IDENT 
		#/* Parse integer literals */
		elif self.charClass==self.DIGIT:
			self.addChar() 
			self.getChar() 
			while self.charClass == self.DIGIT:
				self.addChar() 
				self.getChar() 
			
			self.nextToken = self.INT_LIT 
		
		#/* Parentheses and operators */
		elif self.charClass==self.UNKNOWN:
			
			self.lookup(self.nextChar) 
			self.getChar() 
		#/* EOF */
		elif self.charClass== -1:
			self.nextToken =  -1 
			
			self.lexeme.append('E') 
			self.lexeme.append('O') 
			self.lexeme.append('F') 
			
		
		print "Next token is:",self.nextToken,", Next lexeme is ","".join(self.lexeme)
		return self.nextToken 

# fixed grammar:
# A->id=E
# E->TE'
# E'->{(+|-)TE'}
# T->FT'
# T'->{(*|\)FT'}
# F->(E)|id
# id->(a|b|c)

class recursiveDescent:
	def __init__(self,lexicalAnalyzer):
		self.lexer=lexicalAnalyzer
	def error(self):
		tokens=['+','-','/','*','a','b','c','(',')','=']
		if tokens.count("".join(self.lexer.lexeme))>0:#error caused by lexeme read at a rule
			print "Syntax Error"
		else:
			print "Lexical Error in input. Lexeme","".join(self.lexer.lexeme),"is not in the grammar. Input is not generated by the grammar."

	def iden(self):# A->id=E
		print "Enter <A>"
		if self.lexer.nextToken==self.lexer.IDENT or self.lexer.nextToken==self.lexer.INT_LIT:
			self.id()#parse the id
			if self.lexer.nextToken==self.lexer.ASSIGN_OP:#see if ang susunod ay =
				self.lexer.lex()
				self.expr()#parse expresison
			else:
				self.error()#not = after id
		else:
			self.error()
		if self.lexer.noParen!=0:#same no. of ( and ) in the input
			self.error()
		print "Exit <A>"
	def expr(self):#E->TE'
		print "Enter <E>"
		self.term()#parse the first term
		self.exprP()
		print "Exit <E>"
	def exprP(self):# E'->{(+|-)TE'}
		print "Enter <E'>"
		while self.lexer.nextToken==self.lexer.ADD_OP or self.lexer.nextToken==self.lexer.SUB_OP:#as long as + or - comes next
			self.lexer.lex()
			self.term()
		print "Exit <E'>"
	def term(self):# T->FT'
		print "Enter <T>"
		self.factor()#parse the first factor
		self.termP()
		print "Exit <T>"
	def termP(self):# T'->{(*|\)FT'}
		print "Enter <T'>"
		while self.lexer.nextToken==self.lexer.MULT_OP or self.lexer.nextToken==self.lexer.DIV_OP:#as long as * or / comes next
			self.lexer.lex()
			self.factor()
		print "Exit <T'>"
	def factor(self):# F->(E)|id
		print "Enter <F>"
		#self.lexer.lex()
		if self.lexer.nextToken==self.lexer.IDENT or self.lexer.nextToken==self.lexer.INT_LIT:
			#self.lexer.lex()#get token 
			self.id()

		else: #(<expr>)
			if self.lexer.nextToken==self.lexer.LEFT_PAREN:
				self.lexer.lex()
				self.expr()
				if self.lexer.nextToken==self.lexer.RIGHT_PAREN:
					self.lexer.lex()
				else:
					self.error()
			else: #It was not an id, an integer literal, or a left parenthesis
				self.error()
		print "Exit <F>"
	def id(self):# id->(a|b|c)
		print "Enter <id>"
		self.lexer.lex()
		print "Exit <id>"
		


def main():
	
	
	# lexer=lexicalAnalyzer()
	# lexer.in_fp="(a+b)/c"
	# lexer.getChar()
	# lexer.lex()
	rec=recursiveDescent(lexicalAnalyzer())
	#rec.lexer.in_fp="b=a+c"
	rec.lexer.in_fp=raw_input("Enter your input: ")
	rec.lexer.getChar()
	rec.lexer.lex()
	rec.iden()
	# while lexer.nextToken!=-1:
	# 	lexer.lex()

		

		
if __name__ == '__main__':
	main()